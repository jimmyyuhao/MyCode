---- is_METROPOLIS Matches (18 in 8 files) ----
.tags:is_METROPOLIS	.\ethereum\new_state.py	/^    def is_METROPOLIS(self, at_fork_height=False):$/;"	m	class:State
.tags:is_METROPOLIS	.\ethereum\state.py	/^    def is_METROPOLIS(self, at_fork_height=False):$/;"	m	class:State
.tags_sorted_by_file:is_METROPOLIS	ethereum\new_state.py	/^    def is_METROPOLIS(self, at_fork_height=False):$/;"	m	class:State
.tags_sorted_by_file:is_METROPOLIS	ethereum\state.py	/^    def is_METROPOLIS(self, at_fork_height=False):$/;"	m	class:State
Consensus.py (ethereum\hybrid_casper):    if state.is_METROPOLIS(at_fork_height=True):
Consensus.py (ethereum\pow):    # if state.is_METROPOLIS(at_fork_height=True):
Messages.py (ethereum):    # if state.is_METROPOLIS() or SKIP_RECEIPT_ROOT_VALIDATION:
Messages.py (ethereum):    if not state.is_METROPOLIS() and not SKIP_MEDSTATES:
Messages.py (ethereum):        self.post_metropolis_hardfork = lambda: state.is_METROPOLIS()
New_state.py (ethereum):    def is_METROPOLIS(self, at_fork_height=False):
Pyethereum-develop.sublime-workspace:=False):$/;\"\tm\tclass:State\n 1463: is_DAO\t.\\ethereum\\state.py\t/^    def is_DAO(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1464: is_HOMESTEAD\t.\\ethereum\\new_state.py\t/^    def is_HOMESTEAD(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1465: is_HOMESTEAD\t.\\ethereum\\state.py\t/^    def is_HOMESTEAD(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1466: is_METROPOLIS\t.\\ethereum\\new_state.py\t/^    def is_METROPOLIS(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1467: is_METROPOLIS\t.\\ethereum\\state.py\t/^    def is_METROPOLIS(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1468: is_SERENITY\t.\\ethereum\\new_state.py\t/^    def is_SERENITY(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1469: is_SERENITY\t.\\ethereum\\state.py\t/^    def is_SERENITY(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1470: is_SPURIOUS_DRAGON\t.\\ethereum\\new_state.py\t/^    def is_SPURIOUS_DRAGON(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1471: is_SPURIOUS_DRAGON\t.\\ethereum\\state.py\t/^    def is_SPURIOUS_DRAGON(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1472  is_active\t.\\ethereum\\slogging.py\t/^    def is_active(self, level_name='trace'):$/;\"\tm\tclass:SLogger\n 1473  is_blank\t.\\ethereum\\new_state.py\t/^    def is_blank(self):$/;\"\tm\tclass:Account\n ....\n 1644  make_withdrawal_signature\t.\\ethereum\\todo_tests\\test_pos.py\t/^    make_withdrawal_signature$/;\"\ti\n 1645  match\t.\\ethereum\\__init__.py\t/^        match = GIT_DESCRIBE_RE.match(rev)$/;\"\tv\n 1646: max_capacity\t.\\ethereum\\slogging.py\t/^    max_capacity = 1000 * 1000  # check we are not forgotten or abused$/;\"\tv\tclass:LogRecorder\n 1647  mem_extend\t.\\ethereum\\experimental\\fastvm.py\t/^def mem_extend(mem, compustate, op, start, sz):$/;\"\tf\n 1648  mem_extend\t.\\ethereum\\fastvm.py\t/^def mem_extend(mem, compustate, op, start, sz):$/;\"\tf\n ....\n 1741  not_a_difficulty_test\t.\\ethereum\\tests\\test_difficulty.py\t/^def not_a_difficulty_test(filename, testname, testdata):$/;\"\tf\n 1742  null_address\t.\\ethereum\\messages.py\t/^null_address = b'\\\\xff' * 20$/;\"\tv\n 1743: null_address\t.\\ethereum\\tests\\test_transactions.py\t/^from ethereum.messages import config_fork_specific_validation, null_address$/;\"\ti\n 1744  null_address\t.\\ethereum\\transactions.py\t/^null_address = b'\\\\xff' * 20$/;\"\tv\n 1745  num_blks\t.\\ethereum\\todo_tests\\tst_frontier.py\t/^            num_blks = 0$/;\"\tv\n ....\n 1840  print_function\t.\\ethereum\\abi.py\t/^from __future__ import print_function$/;\"\ti\n 1841  printers\t.\\ethereum\\utils.py\t/^printers = {$/;\"\tv\n 1842: privkeys\t.\\ethereum\\todo_tests\\test_pos.py\t/^privkeys = [utils.sha3(str(i)) for i in range(NUM_PARTICIPANTS)]$/;\"\tv\n 1843  privtoaddr\t.\\ethereum\\tools\\keys.py\t/^def privtoaddr(x):$/;\"\tf\n 1844  privtoaddr\t.\\ethereum\\tools\\tester.py\t/^from ethereum.utils import sha3, privtoaddr, int_to_addr, to_string, big_endian_to_int, checksum_encode, int_to_big_endian, encode_hex$/;\"\ti\n ....\n 1900  pytest_generate_tests\t.\\ethereum\\tests\\test_transactions.py\t/^def pytest_generate_tests(metafunc):$/;\"\tf\n 1901  pytest_generate_tests\t.\\ethereum\\todo_tests\\test_vm.py\t/^def pytest_generate_tests(metafunc):$/;\"\tf\n 1902: randaos\t.\\ethereum\\todo_tests\\test_pos.py\t/^randaos = [RandaoManager(utils.sha3(str(i))) for i in range(NUM_PARTICIPANTS)]$/;\"\tv\n 1903  randint\t.\\ethereum\\pow\\ethash.py\t/^    from random import randint$/;\"\ti\n 1904  random\t.\\ethereum\\pow\\chain.py\t/^import random$/;\"\ti\n ....\n 2077  snapshot\t.\\ethereum\\todo_tests\\tst_frontier.py\t/^def snapshot(c, num_blocks):$/;\"\tf\n 2078  snapshot\t.\\ethereum\\tools\\tester.py\t/^    def snapshot(self):$/;\"\tm\tclass:Chain\n 2079: snapshot_form\t.\\ethereum\\new_state.py\t/^def snapshot_form(val):$/;\"\tf\n 2080: snapshot_form\t.\\ethereum\\snapshot.py\t/^def snapshot_form(val):$/;\"\tf\n 2081: snapshot_form\t.\\ethereum\\state.py\t/^def snapshot_form(val):$/;\"\tf\n 2082  solc_ar
Pyethereum-develop.sublime-workspace:n  794: is_ANTI_DOS\tethereum\\new_state.py\t/^    def is_ANTI_DOS(self, at_fork_height=False):$/;\"\tm\tclass:State\n  795: is_DAO\tethereum\\new_state.py\t/^    def is_DAO(self, at_fork_height=False):$/;\"\tm\tclass:State\n  796: is_HOMESTEAD\tethereum\\new_state.py\t/^    def is_HOMESTEAD(self, at_fork_height=False):$/;\"\tm\tclass:State\n  797: is_METROPOLIS\tethereum\\new_state.py\t/^    def is_METROPOLIS(self, at_fork_height=False):$/;\"\tm\tclass:State\n  798: is_SERENITY\tethereum\\new_state.py\t/^    def is_SERENITY(self, at_fork_height=False):$/;\"\tm\tclass:State\n  799: is_SPURIOUS_DRAGON\tethereum\\new_state.py\t/^    def is_SPURIOUS_DRAGON(self, at_fork_height=False):$/;\"\tm\tclass:State\n  800  is_blank\tethereum\\new_state.py\t/^    def is_blank(self):$/;\"\tm\tclass:Account\n  801  is_numeric\tethereum\\new_state.py\t/^    decode_hex, sha3, is_string, is_numeric$/;\"\ti\n  ...\n  819  sha3\tethereum\\new_state.py\t/^    decode_hex, sha3, is_string, is_numeric$/;\"\ti\n  820  snapshot\tethereum\\new_state.py\t/^    def snapshot(self):$/;\"\tm\tclass:State\n  821: snapshot_form\tethereum\\new_state.py\t/^def snapshot_form(val):$/;\"\tf\n  822  sys\tethereum\\new_state.py\t/^import sys$/;\"\ti\n  823  to_dict\tethereum\\new_state.py\t/^    def to_dict(self):$/;\"\tm\tclass:Account\n  ...\n 1091  error\tethereum\\slogging.py\t/^    error = lambda self, *args, **kwargs: self._proxy('error', *args, **kwargs)$/;\"\tv\tclass:BoundLogger\n 1092  exception\tethereum\\slogging.py\t/^    exception = lambda self, *args, **kwargs: self._proxy('exception', *args, **kwargs)$/;\"\tv\tclass:BoundLogger\n 1093: format_message\tethereum\\slogging.py\t/^    def format_message(self, msg, kwargs, highlight, level):$/;\"\tm\tclass:SLogger\n 1094  getLogger\tethereum\\slogging.py\t/^    def getLogger(self, name):$/;\"\tm\tclass:SManager\n 1095  getLogger\tethereum\\slogging.py\t/^def getLogger(name=None):$/;\"\tf\n ....\n 1106  log_listeners\tethereum\\slogging.py\t/^log_listeners = []$/;\"\tv\n 1107  logging\tethereum\\slogging.py\t/^import logging$/;\"\ti\n 1108: max_capacity\tethereum\\slogging.py\t/^    max_capacity = 1000 * 1000  # check we are not forgotten or abused$/;\"\tv\tclass:LogRecorder\n 1109  pop_records\tethereum\\slogging.py\t/^    def pop_records(self):$/;\"\tm\tclass:LogRecorder\n 1110  rootLogger\tethereum\\slogging.py\t/^rootLogger = RootLogger(DEFAULT_LOGLEVEL)$/;\"\tv\n ....\n 1145  rlp\tethereum\\snapshot.py\t/^import rlp$/;\"\ti\n 1146  scan_bin\tethereum\\snapshot.py\t/^from ethereum.utils import is_numeric, is_string, encode_hex, decode_hex, zpad, scan_bin, big_endian_to_int$/;\"\ti\n 1147: snapshot_form\tethereum\\snapshot.py\t/^def snapshot_form(val):$/;\"\tf\n 1148  zpad\tethereum\\snapshot.py\t/^from ethereum.utils import is_numeric, is_string, encode_hex, decode_hex, zpad, scan_bin, big_endian_to_int$/;\"\ti\n 1149  ZERO_PRIVKEY_ADDR\tethereum\\specials.py\t/^ZERO_PRIVKEY_ADDR = decode_hex('3f17f1962b36e491b30a40b2405849e597ba5fb5')$/;\"\tv\n ....\n 1236  int256\tethereum\\state.py\t/^    decode_hex, sha3, is_string, is_numeric$/;\"\ti\n 1237  int_to_addr\tethereum\\state.py\t/^    decode_hex, sha3, is_string, is_numeric$/;\"\ti\n 1238: is_ANTI_DOS\tethereum\\state.py\t/^    def is_ANTI_DOS(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1239: is_DAO\tethereum\\state.py\t/^    def is_DAO(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1240: is_HOMESTEAD\tethereum\\state.py\t/^    def is_HOMESTEAD(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1241: is_METROPOLIS\tethereum\\state.py\t/^    def is_METROPOLIS(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1242: is_SERENITY\tethereum\\state.py\t/^    def is_SERENITY(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1243: is_SPURIOUS_DRAGON\tethereum\\state.py\t/^    def is_SPURIOUS_DRAGON(self, at_fork_height=False):$/;\"\tm\tclass:State\n 1244  is_blank\tethereum\\state.py\t/^    def is_blank(self):$/;\"\tm\tclass:Account\n 1245  is_numeric\tethereum\\state.py\t/^    decode_hex, sha3, is_s
Pyethereum-develop.sublime-workspace:ize(t))\n   73:                        for t in self.topics]\n   74          }\n   75  \n   ..\n  100      @property\n  101      def bloom(self):\n  102:         bloomables = [x.bloomables() for x in self.logs]\n  103          return bloom.bloom_from_list(utils.flatten(bloomables))\n  104  \n  ...\n  108      return Receipt(state.trie.root_hash, state.gas_used, logs)\n  109  \n  110: def config_fork_specific_validation(config, blknum, tx):\n  111      # (1) The transaction signature is valid;\n  112      _ = tx.sender\n  ...\n  132          raise UnsignedTransaction(tx)\n  133  \n  134:     assert config_fork_specific_validation(state.config, state.block_number, tx)\n  135  \n  136      # (2) the transaction nonce is valid (equivalent to the\n  ...\n  197      state.delta_balance(tx.sender, -tx.startgas * tx.gasprice)\n  198  \n  199:     message_data = vm.CallData([safe_ord(x) for x in tx.data], 0, len(tx.data))\n  200      message = vm.Message(tx.sender, tx.to, tx.value, tx.startgas - intrinsic_gas, message_data, code_address=tx.to)\n  201  \n  ...\n  246      suicides = state.suicides\n  247      state.suicides = []\n  248:     for s in suicides:\n  249          state.set_balance(s, 0)\n  250          state.del_account(s)\n  ...\n  271  \n  272      def __init__(self, state, tx):\n  273:         self.specials = {k:v for k, v in default_specials.items()}\n  274:         for k, v in state.config['CUSTOM_SPECIALS']:\n  275              self.specials[k] = v\n  276          self._state = state\n  ...\n  300          self.msg = lambda msg: _apply_msg(self, msg, self.get_code(msg.code_address))\n  301          self.account_exists = state.account_exists\n  302:         self.post_homestead_hardfork = lambda: state.is_HOMESTEAD()\n  303:         self.post_metropolis_hardfork = lambda: state.is_METROPOLIS()\n  304:         self.post_serenity_hardfork = lambda: state.is_SERENITY()\n  305:         self.post_anti_dos_hardfork = lambda: state.is_ANTI_DOS()\n  306:         self.post_spurious_dragon_hardfork = lambda: state.is_SPURIOUS_DRAGON()\n  307          self.blockhash_store = state.config['METROPOLIS_BLOCKHASH_STORE']\n  308          self.snapshot = state.snapshot\n  ...\n  362          ext.increment_nonce(msg.sender)\n  363  \n  364:     if ext.post_metropolis_hardfork() and msg.sender == null_address:\n  365          msg.to = utils.mk_contract_address(msg.sender, 0)\n  366          # msg.to = sha3(msg.sender + code)[12:]\n  ...\n  369          msg.to = utils.mk_contract_address(msg.sender, nonce)\n  370  \n  371:     if ext.post_metropolis_hardfork() and (ext.get_nonce(msg.to) or len(ext.get_code(msg.to))):\n  372          log_msg.debug('CREATING CONTRACT ON TOP OF EXISTING CONTRACT')\n  373          return 0, 0, b''\n  ...\n  386      snapshot = ext.snapshot()\n  387  \n  388:     ext.set_nonce(msg.to, 1 if ext.post_spurious_dragon_hardfork() else 0)\n  389      res, gas, dat = _apply_msg(ext, msg, code)\n  390  \n  ...\n  396              return 1, gas, msg.to\n  397          gcost = len(dat) * opcodes.GCONTRACTBYTE\n  398:         if gas >= gcost and (len(dat) <= 24576 or not ext.post_spurious_dragon_hardfork()):\n  399              gas -= gcost\n  400          else:\n  401              dat = []\n  402              log_msg.debug('CONTRACT CREATION FAILED', have=gas, want=gcost, block_number=ext.block_number)\n  403:             if ext.post_homestead_hardfork():\n  404                  ext.revert(snapshot)\n  405                  return 0, 0, b''\n\nD:\\MyCode\\Code\\ChainBlock\\pyethereum-develop\\ethereum\\meta.py:\n   25          assert validate_transaction_tree(state, block)\n   26          # Process transactions\n   27:         for tx in block.transactions:\n   28              apply_transaction(state, tx)\n   29          # Finalize (incl paying block rewards)\n   ..\n   31          # Verify state root, tx list root, receipt root\n   32          assert verify_execution_results(state, block)\n   33:         # Post-finalize (ie. add the block header to the state for now)\n   34    
Pyethereum-develop.sublime-workspace: 35      except (ValueError, AssertionError) as e:\n\nD:\\MyCode\\Code\\ChainBlock\\pyethereum-develop\\ethereum\\new_state.py:\n   24  BLANK_ROOT = utils.sha3rlp(b'')\n   25  \n   26: def snapshot_form(val):\n   27      if is_numeric(val):\n   28          return str(val)\n   ..\n   70  \n   71      def commit(self):\n   72:         for k, v in self.storage_cache.items():\n   73              if v:\n   74                  self.storage_trie.update(utils.encode_int32(k), rlp.encode(v))\n   ..\n  118      def to_dict(self):\n  119          odict = self.storage_trie.to_dict()\n  120:         for k, v in self.storage_cache.items():\n  121              odict[utils.encode_int(k)] = rlp.encode(utils.encode_int(v))\n  122          return {'balance': str(self.balance), 'nonce': str(self.nonce), 'code': '0x'+encode_hex(self.code),\n  123                  'storage': {'0x'+encode_hex(key.lstrip(b'\\x00') or b'\\x00'):\n  124:                             '0x'+encode_hex(rlp.decode(val)) for key, val in odict.items()} }\n  125  \n  126  #from ethereum.state import State\n  ...\n  131          self.env = env\n  132          self.trie = SecureTrie(Trie(self.db, root))\n  133:         for k, v in STATE_DEFAULTS.items():\n  134              setattr(self, k, kwargs.get(k, copy.copy(v)))\n  135          self.journal = []\n  ...\n  228  \n  229      def add_log(self, log):\n  230:         for listener in self.log_listeners:\n  231              listener(log)\n  232          self.logs.append(log)\n  ...\n  243  \n  244      def snapshot(self):\n  245:         return (self.trie.root_hash, len(self.journal), {k: copy.copy(getattr(self, k)) for k in STATE_DEFAULTS})\n  246  \n  247      def revert(self, snapshot):\n  ...\n  254              self.trie.root_hash = h\n  255              self.cache = {}\n  256:         for k in STATE_DEFAULTS:\n  257              setattr(self, k, copy.copy(auxvars[k]))\n  258  \n  ...\n  262          setattr(self, k, v)\n  263  \n  264:     def is_SERENITY(self, at_fork_height=False):\n  265:         if at_fork_height: return self.block_number == self.config['SERENITY_FORK_BLKNUM']\n  266          else: return self.block_number >= self.config['SERENITY_FORK_BLKNUM']\n  267  \n  268:     def is_HOMESTEAD(self, at_fork_height=False):\n  269:         if at_fork_height: return self.block_number == self.config['HOMESTEAD_FORK_BLKNUM']\n  270          else: return self.block_number >= self.config['HOMESTEAD_FORK_BLKNUM']\n  271  \n  272:     def is_METROPOLIS(self, at_fork_height=False):\n  273:         if at_fork_height: return self.block_number == self.config['METROPOLIS_FORK_BLKNUM']\n  274          else: return self.block_number >= self.config['METROPOLIS_FORK_BLKNUM']\n  275  \n  276:     def is_ANTI_DOS(self, at_fork_height=False):\n  277:         if at_fork_height: return self.block_number == self.config['ANTI_DOS_FORK_BLKNUM']\n  278          else: return self.block_number >= self.config['ANTI_DOS_FORK_BLKNUM']\n  279  \n  280:     def is_SPURIOUS_DRAGON(self, at_fork_height=False):\n  281:         if at_fork_height: return self.block_number == self.config['SPURIOUS_DRAGON_FORK_BLKNUM']\n  282          else: return self.block_number >= self.config['SPURIOUS_DRAGON_FORK_BLKNUM']\n  283  \n  284:     def is_DAO(self, at_fork_height=False):\n  285:         if at_fork_height: return self.block_number == self.config['DAO_FORK_BLKNUM']\n  286          else: return self.block_number >= self.config['DAO_FORK_BLKNUM']\n  287  \n  ...\n  309  \n  310      def commit(self, allow_empties=False):\n  311:         for addr, acct in self.cache.items():\n  312              if acct.touched:\n  313                  acct.commit()\n  ...\n  322  \n  323      def to_dict(self):\n  324:         for addr in self.trie.to_dict().keys():\n  325              self.get_and_cache_account(addr)\n  326:         return {encode_hex(addr): acct.to_dict() for addr, acct in self.cache.items()}\n  327  \n  328      def del_account(self, address):\n  ...\n  346          snapshot = {}\n  347          if root_only:\n 
Pyethereum-develop.sublime-workspace: return 1, msg.gas, []\n  143      import py_ecc.optimized_bn128 as bn128\n  ...\n  154      o = bn128.normalize(bn128.multiply(p, m))\n  155      return (1, msg.gas - opcodes.GECMUL,\n  156:             [safe_ord(c) for c in (encode_int32(o[0].n) + encode_int32(o[1].n))])\n  157  \n  158  def proc_ecpairing(ext, msg):\n  159:     if not ext.post_metropolis_hardfork():\n  160          return 1, msg.gas, []\n  161      import py_ecc.optimized_bn128 as bn128\n  ...\n  170      zero = (bn128.FQ2.one(), bn128.FQ2.one(), bn128.FQ2.zero())\n  171      exponent = bn128.FQ12.one()\n  172:     for i in range(0, msg.data.size, 192):\n  173          x1 = msg.data.extract32(i)\n  174          y1 = msg.data.extract32(i + 32)\n  ...\n  180          if p1 is False:\n  181              return 0, 0, []\n  182:         for v in (x2_i, x2_r, y2_i, y2_r):\n  183              if v >= bn128.field_modulus:\n  184                  return 0, 0, []\n  ...\n  198  \n  199  specials = {\n  200:     decode_hex(k): v for k, v in\n  201      {\n  202          b'0000000000000000000000000000000000000001': proc_ecrecover,\n\nD:\\MyCode\\Code\\ChainBlock\\pyethereum-develop\\ethereum\\state.py:\n   26  THREE = b'\\x00' * 19 + b'\\x03'\n   27  \n   28: def snapshot_form(val):\n   29      if is_numeric(val):\n   30          return str(val)\n   ..\n   73  \n   74      def commit(self):\n   75:         for k, v in self.storage_cache.items():\n   76              if v:\n   77                  self.storage_trie.update(utils.encode_int32(k), rlp.encode(v))\n   ..\n  120      def to_dict(self):\n  121          odict = self.storage_trie.to_dict()\n  122:         for k, v in self.storage_cache.items():\n  123              odict[utils.encode_int(k)] = rlp.encode(utils.encode_int(v))\n  124          return {'balance': str(self.balance), 'nonce': str(self.nonce), 'code': '0x'+encode_hex(self.code),\n  125                  'storage': {'0x'+encode_hex(key.lstrip(b'\\x00') or b'\\x00'):\n  126:                             '0x'+encode_hex(rlp.decode(val)) for key, val in odict.items()} }\n  127  \n  128  #from ethereum.state import State\n  ...\n  132          self.env = env\n  133          self.trie = SecureTrie(Trie(RefcountDB(self.db), root))\n  134:         for k, v in STATE_DEFAULTS.items():\n  135              setattr(self, k, kwargs.get(k, copy.copy(v)))\n  136          self.journal = []\n  ...\n  238  \n  239      def add_log(self, log):\n  240:         for listener in self.log_listeners:\n  241              listener(log)\n  242          self.logs.append(log)\n  ...\n  253  \n  254      def snapshot(self):\n  255:         return (self.trie.root_hash, len(self.journal), {k: copy.copy(getattr(self, k)) for k in STATE_DEFAULTS})\n  256  \n  257      def revert(self, snapshot):\n  ...\n  268              self.trie.root_hash = h\n  269              self.cache = {}\n  270:         for k in STATE_DEFAULTS:\n  271              setattr(self, k, copy.copy(auxvars[k]))\n  272          if three_touched and 2675000 < self.block_number < 2675200 : # Compatibility with weird geth+parity bug\n  ...\n  278          setattr(self, k, v)\n  279  \n  280:     def is_SERENITY(self, at_fork_height=False):\n  281:         if at_fork_height: return self.block_number == self.config['SERENITY_FORK_BLKNUM']\n  282          else: return self.block_number >= self.config['SERENITY_FORK_BLKNUM']\n  283  \n  284:     def is_HOMESTEAD(self, at_fork_height=False):\n  285:         if at_fork_height: return self.block_number == self.config['HOMESTEAD_FORK_BLKNUM']\n  286          else: return self.block_number >= self.config['HOMESTEAD_FORK_BLKNUM']\n  287  \n  288:     def is_METROPOLIS(self, at_fork_height=False):\n  289:         if at_fork_height: return self.block_number == self.config['METROPOLIS_FORK_BLKNUM']\n  290          else: return self.block_number >= self.config['METROPOLIS_FORK_BLKNUM']\n  291  \n  292:     def is_ANTI_DOS(self, at_fork_height=False):\n  293:         if at_fork_height: return self.block_number == self.config['ANTI_DOS_FORK_BLKNUM
Pyethereum-develop.sublime-workspace:k(chain.db.get('GENESIS_HASH')))\n  265:     potential_uncles = [x for x in descendants if x not in chain and isinstance(x, Block)]\n  266:     uncles = [x.header for x in potential_uncles if not call_casper(chain.state, 'isDunkleIncluded', [x.header.hash])]\n  267      dunkle_txs = []\n  268      ct = get_casper_ct()\n  269      start_nonce = state.get_nonce(state.config['METROPOLIS_ENTRY_POINT'])\n  270:     for i, u in enumerate(uncles[:4]):\n  271          txdata = ct.encode('includeDunkle', [rlp.encode(u)])\n  272          dunkle_txs.append(Transaction(start_nonce + i, 0, 650000, chain.config['CASPER_ADDR'], 0, txdata))\n  ...\n  292      blk.uncles = []\n  293      initialize(state, blk)\n  294:     for tx in get_dunkle_candidates(chain, state):\n  295          assert apply_transaction(state, tx)\n  296          blk.transactions.append(tx)\n\nD:\\MyCode\\Code\\ChainBlock\\pyethereum-develop\\ethereum\\hybrid_casper\\consensus.py:\n    6      state.gas_limit = block.header.gas_limit\n    7      state.block_number = block.header.number\n    8:     state.recent_uncles[state.block_number] = [x.hash for x in block.uncles]\n    9      state.block_coinbase = block.header.coinbase\n   10      state.block_difficulty = block.header.difficulty\n   ..\n   22          update_block_env_variables(state, block)\n   23  \n   24:     if state.is_DAO(at_fork_height=True):\n   25:         for acct in state.config['CHILD_DAO_LIST']:\n   26              state.transfer_value(acct, state.config['DAO_WITHDRAWER'], state.get_balance(acct))\n   27  \n   28:     if state.is_METROPOLIS(at_fork_height=True):\n   29          state.set_code(utils.normalize_address(\n   30              config[\"METROPOLIS_STATEROOT_STORE\"]), config[\"METROPOLIS_GETTER_CODE\"])\n\nD:\\MyCode\\Code\\ChainBlock\\pyethereum-develop\\ethereum\\pow\\chain.py:\n  119          b = block\n  120          header_depth = state.config['PREV_HEADER_DEPTH']\n  121:         for i in range(header_depth + 1):\n  122              state.prev_headers.append(b.header)\n  123              if i < 6:\n  124                  state.recent_uncles[state.block_number - i] = []\n  125:                 for u in b.uncles:\n  126                      state.recent_uncles[state.block_number - i].append(u.hash)\n  127              try:\n  ...\n  132              if state.db.get(b.header.prevhash) == 'GENESIS':\n  133                  jsondata = json.loads(state.db.get('GENESIS_STATE'))\n  134:                 for h in jsondata[\"prev_headers\"][:header_depth - i]:\n  135                      state.prev_headers.append(dict_to_prev_header(h))\n  136:                 for blknum, uncles in jsondata[\"recent_uncles\"].items():\n  137                      if int(blknum) >= state.block_number - int(state.config['MAX_UNCLE_DEPTH']):\n  138:                         state.recent_uncles[blknum] = [parse_as_bin(u) for u in uncles]\n  139              else:\n  140                  raise Exception(\"Dangling prevhash\")\n  ...\n  170              existing = b''\n  171          existing_hashes = []\n  172:         for i in range(0, len(existing), 32):\n  173              existing_hashes.append(existing[i: i+32])\n  174          if child.header.hash not in existing_hashes:\n  ...\n  191          try:\n  192              data = self.db.get(b'child:' + blockhash)\n  193:             for i in range(0, len(data), 32):\n  194                  o.append(data[i:i + 32])\n  195              return o\n  ...\n  203          if isinstance(block, BlockHeader):\n  204              block = block.hash\n  205:         return [self.get_block(h) for h in self.get_child_hashes(block)]\n  206  \n  207      # Get the score (AKA total difficulty in PoW) of a given block\n  ...\n  217              block = self.get_parent(block)\n  218          score = int(self.db.get(key))\n  219:         for h,d in fills:\n  220              key = b'score:' + h\n  221              score = score + d + random.randrange(d // 10**6 + 1)\n  ...\n  246                  i += 1\n  247              self.time_queue.insert(i
Pyethereum-develop.sublime-workspace:   rdb = RefcountDB(self.db)\n  379:                 for i in range(0, len(deletes), 32):\n  380                      rdb.delete(deletes[i: i+32])\n  381                  self.db.delete(b'deletes:'+old_block_hash)\n  ...\n  392          if self.new_head_cb and block.header.number != 0:\n  393              self.new_head_cb(block)\n  394:         # Are there blocks that we received that were waiting for this block?\n  395          # If so, process them.\n  396          if block.header.hash in self.parent_queue:\n  397:             for _blk in self.parent_queue[block.header.hash]:\n  398                  self.add_block(_blk)\n  399              del self.parent_queue[block.header.hash]\n  ...\n  423              frm = int(self.db.get('GENESIS_NUMBER')) + 1\n  424          chain = []\n  425:         for i in itertools.islice(itertools.count(), frm, to):\n  426              h = self.get_blockhash_by_number(i)\n  427              if not h:\n  ...\n  467          header = block.header\n  468          hashes = []\n  469:         for i in xrange(max):\n  470              hash = header.prevhash\n  471              block = self.get_block(hash)\n\nD:\\MyCode\\Code\\ChainBlock\\pyethereum-develop\\ethereum\\pow\\consensus.py:\n   17          update_block_env_variables(state, block)\n   18  \n   19:     if state.is_DAO(at_fork_height=True):\n   20:         for acct in state.config['CHILD_DAO_LIST']:\n   21              state.transfer_value(acct, state.config['DAO_WITHDRAWER'], state.get_balance(acct))\n   22  \n   23:     # if state.is_METROPOLIS(at_fork_height=True):\n   24      #     state.set_code(utils.normalize_address(\n   25      #         config[\"METROPOLIS_STATEROOT_STORE\"]), config[\"METROPOLIS_GETTER_CODE\"])\n   ..\n   37      uncles = []\n   38      ineligible = {}\n   39:     for h, _uncles in state.recent_uncles.items():\n   40:         for u in _uncles:\n   41              ineligible[u] = True\n   42:     for i in range(0, min(state.config['MAX_UNCLE_DEPTH'], len((state.prev_headers)))):\n   43          ineligible[state.prev_headers[i].hash] = True\n   44:     for i in range(1, min(state.config['MAX_UNCLE_DEPTH'], len(state.prev_headers))):\n   45          child_hashes = chain.get_child_hashes(state.prev_headers[i].hash)\n   46:         for c in child_hashes:\n   47              if c not in ineligible and len(uncles) < 2:\n   48                  uncles.append(chain.get_block(c).header)\n   ..\n   57      if utils.sha3(rlp.encode(block.uncles)) != block.header.uncles_hash:\n   58          raise VerificationFailed(\"Uncle hash mismatch\")\n   59:     # Enforce maximum number of uncles\n   60      if len(block.uncles) > state.config['MAX_UNCLES']:\n   61          raise VerificationFailed(\"Too many uncles\")\n   62      # Uncle must have lower block number than blockj\n   63:     for uncle in block.uncles:\n   64          if uncle.number >= block.header.number:\n   65              raise VerificationFailed(\"Uncle number too high\")\n   ..\n   67      # Check uncle validity\n   68      MAX_UNCLE_DEPTH = state.config['MAX_UNCLE_DEPTH']\n   69:     ancestor_chain = [block.header] + [a for a in state.prev_headers[:MAX_UNCLE_DEPTH + 1] if a]\n   70      # Uncles of this block cannot be direct ancestors and cannot also\n   71      # be uncles included 1-6 blocks ago\n   72:     ineligible = [b.hash for b in ancestor_chain]\n   73:     for blknum, uncles in state.recent_uncles.items():\n   74          if state.block_number > int(blknum) >= state.block_number - MAX_UNCLE_DEPTH:\n   75:             ineligible.extend([u for u in uncles])\n   76:     eligible_ancestor_hashes = [x.hash for x in ancestor_chain[2:]]\n   77:     for uncle in block.uncles:\n   78          if uncle.prevhash not in eligible_ancestor_hashes:\n   79              raise VerificationFailed(\"Uncle does not have a valid ancestor\")\n   80:         parent = [x for x in ancestor_chain if x.hash == uncle.prevhash][0]\n   81          if uncle.difficulty != calc_difficulty(parent, uncle.timestamp, config=state.config):\n   82
State.py (ethereum):    def is_METROPOLIS(self, at_fork_height=False):
---- is_METROPOLIS Search Errors Encountered (2) ----
The following 2 files could not be processed:
D:\MyCode\Code\ChainBlock\pyethereum-develop\siprj\pyethereum-develop.IAB : File could not be opened.
D:\MyCode\Code\ChainBlock\pyethereum-develop\siprj\pyethereum-develop.IMB : File could not be opened.
